红瞳:
我在想多方聊天应该怎么做。暂时限制 webrtc 采用 mesh 方案（https://blog.51cto.com/u_15284125/2987476）。
首先服务端要维持房间，每个房间有个用户列表，每个用户都有在线状态（需要客户端心跳）。
然后，如果是那种不限制人数的聊天，来一个就聊一个，那么：第一个用户来了，获取用户列表，除了自己没别人，于是除了发心跳，什么都不做；第二个用户来了，获取用户列表，发现除了自己还有一个人，于是生成 RTCPeerConnection, 把自己的信令发给服务端，让服务端转发给第一个人。
于是这一步我就觉得很奇怪，你说发给第一个人就要发给第一个人啊，万一你不是这个房间里的人呢？所以我们还要检测这个人是不是房间里的人。于是这个逻辑我就觉得太过奇怪，职责不清晰。另外，用户在线状态可能是在线的，但万一与其他用户间的 RTCPeerConnection 没有连接成功怎么办，那还算在线吗？

林秦敏:
你那种应该要用MCU方案把

红瞳:
mcu 是不错，不过它不是占流量吗，还要做更多的事情。

红瞳:
现在比如 我 弄个最多 5 人的聊天室。有的是 动态人数的聊天室，两个人就可以聊了。有的是静态人数的聊天室，4人要等所有人准备好后才开始聊

红瞳:
这里面是个怎样的抽象的逻辑呢

如实观照:
栅栏

如实观照:
人齐了，开饭

林秦敏:
如果用Mesh方式，你确定可以用？我怎么感觉像Chrome浏览器最原始的那种WebRTC呢，单对单聊天

红瞳:
一开始想的是 服务器跟客户端就一个 ws 连接，然后所有客户端对所有其他客户端和服务器的状态都清楚，然后该发什么消息给谁，就发什么消息给谁，通过服务器中转。但觉得这个太复杂了，而且错误状态会非常多，根本不可能做到。
然后想着干脆服务器只复杂 room 状态的广播，纯粹由客户端完全负责修改 room 状态，但这样会引发数据竞争错误，和权限问题，还得有个共识（干）。
现在想着，服务器ws连接负责广播 room 状态，rest接口负责按权限去更改 room 状态，这样看似差不多，但还是有 room 状态内部可能有一些状态需要按权限查看，例如第 4 个人进入聊天室，应该发三个连接信令，然后服务器把三个连接信令分配给上面的三个人，放进 room 状态了广播，可如果有一个内鬼把所有三个信令都给占据了怎么办？

林秦敏:
你用WebRtc 你还得穿透。

林秦敏:
可以考虑一下网上成熟的MCU框架。

红瞳:
可能会想着 为什么要把 room 状态广播，为什么要把 信令放在要被广播的 room 状态上，何不直接把信令单独的发送给某个人。这里我就是觉得需要保留下状态，如果单独的把信令发送给某个人，那之后刚才那个第 4 个进入聊天室的人怎么知道信令有没有发过去，自己是不是应该再发一条信令

红瞳:
那加入说就不是什么 webrtc，而是纯粹的用 websocket 实现的游戏

红瞳:
游戏可以动态多人游戏，也可以固定人数的游戏

红瞳:
感觉这种问题 就是一个 分布式状态同步 + 保密/私信，甚至可能未来还有减少流量（比如room状态太大，每次都全量同步受不了），就这样一种问题吧

岁月静好:
看不懂[捂脸]

raaaay:
又是新名词，太卷了

红瞳:
我怎么了？这种东西应该很常见吧，游戏里是怎么做的？什么卷不卷的，就是好奇，我一个前端，好奇这个叫卷吗，前端卷是别的各种大前端，微前端，受不了。。。

红瞳:
然后出现新名词还不是因为我不懂

Jaymin:
看了半天，连信令是啥都不知道

红瞳:
那就不说信令吧，就一条私信

红瞳:
信令 是 webrtc 的说法，作为两者连接的一个数据，就是告诉对方自己的网络地址

红瞳:
在我这里，其实说信令，其实关注的就是 私信怎么发

我错了，别网暴我:
你们这样做游戏

我错了，别网暴我:
如果遇到弱网咋办

红瞳:
是啊，所以就是好奇啊

我错了，别网暴我:
Ws只要网络差，会一直重试

林秦敏:
用ws 做，webrtc 可以试试腾讯的那的webrtc服务

红瞳:
是，是不是 ws 也无所谓了，大不了轮询也不是不可以。我就是想知道 这种问题 的最佳实践应该是怎么样的

我错了，别网暴我:
我觉得，应该用udp比较多吧

红瞳:
这种问题，首先是多台机器的状态，有一个特殊的机器（服务器）可以做总管，然后要对于部分状态的同步要有私密性

红瞳:
管它 udp，kcp，我这里现在连 tcp 最保险的 都不清楚怎么做这个状态同步

shallow:
我们都是tcp，但是，是不是ws，要看后端和客户端怎么协调了

红瞳:
我之前有做过一款 有些 demo，阿瓦隆，是当时 公司里流行起这个卡牌游戏，于是我做了个网络版。然后虽然我是个前端，偏偏，我是把后端逻辑写得比较完整，反倒是前端真就 啥样式都没有。当时就是 后端维护一个 状态机，所有的该私密的状态，都是透明的，无非就是前端展没展示的问题。

红瞳:
有些 demo --- 游戏demo

红瞳:
游戏开发，状态同步，不应该是很常见，甚至已经很成熟的一个东西吗？应该有很成熟的一套逻辑吧

shallow:
抛开游戏类型谈技术，没什么意义

红瞳:
是，但，我刚才说的那个问题，卡牌游戏就会有用到

红瞳:
卡牌游戏 总是所有网络游戏中最简单的了吧

shallow:
卡牌游戏

shallow:
和分布式有什么关系

shallow:
保密私信又是什么

shallow:
协议解密不好解密的，找一些关键消息，或者字节，直接混淆一下，解不出来什么东西

红瞳:
卡牌游戏，要首先有 room 的概念，一局游戏一个 room 嘛。可能有的游戏允许 人 临时加入或退出，有的不许。room 里有状态，各种公开的游戏状态，也应该有私密的游戏状态，服务器要保留所有的私密的游戏状态，客户端各自保留自己的那一份私密状态。然后可能有私信，比如就是有卡牌游戏允许多方联合，这种私信又要怎么发。

shallow:
游戏内的私信都做的很简单啊

shallow:
直接内部服务器转发一下不就好了

shallow:
反正如果真的意外宕机了

shallow:
对局也会消失

shallow:
也不是和支付系统那样，必须完美严谨

红瞳:
好像这样一说的话，它也不是什么难不难的问题，它就是一个工作量的问题，就是要一个一个做。

红瞳:
私信就是 私密状态的同步

红瞳:
比如你有什么卡牌，肯定要 服务器存一份，你客户端存一份啊。别的客户端肯定不能知道啊。私信 就是 你客户端还要有一个消息列表，服务器也有一份你个人的消息列表，别人给你发私信就是往你给人消息列表插入一条，然后服务器同步给你

shallow:
[捂脸]这不是crud吗

红瞳:
万物皆 crud

shallow:
至于客户端能不能知道，就看具体实现了

# 所以数据模型应设计为
```js
const rooms = {
  [room_id]: {
    // last_access_at 用于判断用户是否在线，room 是否被使用
    // 有一个 setInterval 定时查看整个 rooms 对象，删除离线超过一定时间的 room 和 user
    last_access_at: Date,
    msgs: {from: '', to?: '', data: {}}[], // to 为空的就是发给整个 room 的
    data: {}, // room 的瞬时状态，例如里面有有顺序的用户列表，从而后加入的人知道谁在自己前面，自己应该连接谁
    users: {
      [user_id]: {
        last_access_at: Date,
        // 就 room.msgs 的过滤，例如别人发过来的 webrtc 的 offer
        // 也不一定，可能一个发给整个 room 的 msg，对应多个发给单个人的 msg，减少消息个数
        msgs: {from: '', data: {}}[],
        data: {}, // user 的瞬时状态，简单的聊天一般没有啥 user 的瞬时状态的要求，复杂的业务可能就要根据这个来判断用户有没有开外挂了
      }
    }
  }
}
```
或者此种数据结构由 关系数据库 来存储，之后再 computed 出此种数据结构
