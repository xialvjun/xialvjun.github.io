<!-- # 类型, 依赖与解耦 -->
# 依赖, 解耦与类型

依赖
业务依赖
库与代码包依赖
代码依赖


多余的依赖的实例就有 滴禹微前端 里把城市绑定在子应用上, 而不是直接绑定在页面上, 导致同一个子应用的所有页面都偶合起来了, 共用一个城市设定
不讲这个例子, 可以转换下, 讲 应用放在机器上, 再对机器设置权限啥的...


类型的变化最容易导致大变, 离职证明需要 人物, 公司, 时间, 这就是接口(字段少), 但如果还要加字段, 那就一大堆认得离职证明要重新开了, 说不定有的公司离职证明是系统自动开的, 系统开离职证明没做幂等, 导致不能二次开离职证明, 都是问题

<!-- 一个管理系统,
一开始只有一个用户, 知道这个用户名密码的人就可以登录进行操作.
后来为了记下操作记录, 变成多个用户.
再之后给用户加权限, 这个用户能做什么, 那个用户能做什么.
再再之后设置用户权限太繁琐, 就添加了角色, 用户与角色多对多(也有多对一), 角色与功能多对多.
此时就形成了 RBAC(role based access control).
那这个 RBAC 形成的过程中, 哪些算解耦哦?
一开始只有一个用户, 用户名密码直接写死在代码里, 这就把用户与代码耦合起来了.
变成多用户, 把用户名密码存到数据库的用户表里了, 此时新增一个用户, 修改用户的密码, 都不需要修改代码, 不需要重新部署, 重启服务器, 这算解耦. -->



贫血接口与充血接口

https://zhuanlan.zhihu.com/p/112991455
里氏替换原则
https://www.zhihu.com/question/437583966

鸭子类型

https://zhuanlan.zhihu.com/p/109334326


https://www.zhihu.com/question/20086718/answer/117656234



## 这里有一个示例能很好的体现 依赖，解耦与类型
https://stackoverflow.com/a/69805305/3127028
场景是 把svg图片变成 react 组件，且可以控制里面的一些参数。。。于是在 “依赖，解耦与类型” 这个话题上出现了两种倾向。
第一种，把控制逻辑放进svg里去做，即把 svg 代码拷贝到 jsx 里，手动增加一些变量，从 props 里取值；
第二种，把控制逻辑放到svg外部，即使用了 svg 后，在外部对 svg 做各种变化；

耦合方面
第一种耦合性较低，svg 如果发生一些变化，只要改 svg 组件就可以了，如果 props 部分无需变化，那外部使用方就无需变化；因为**外部使用方只依赖于子组件的 props 接口**
第二种耦合性很高，基本上 svg 稍微发生一点变化，外部就要变；这里是因为**外部使用方在类型上其实已经依赖了子组件的全部的内容，最多是使用上可能依赖也不多**

另一方面：灵活
第一种灵活程度比较低；
第二种灵活程度非常高；

因为这两方面，所以其实也没有谁优谁劣，只是看取舍。但这里必须要记住一点，耦合高的，一定要类型完整。也就是说，这种写法对 ts 类型要求很高：
```tsx
// car.svg
// <svg><circle fill="red"/><rect fill="blue"/></svg>
const vdom = <SvgCar>{vdom => {
  vdom.children[1].fill = 'yellow';
}}</SvgCar>

// 有旧的代码 跟上面的那样，然后有一天，car.svg 发生变化，变成
// <svg><circle fill="red"/></svg>，于是，这段代码
const vdom = <SvgCar>{vdom => {
  vdom.children[1].fill = 'yellow'; // 这里 ts 应该在编译期报 vdom.children[1] 是 undefined
}}</SvgCar>
```

其实上面的 vdom 操作函数不应该做修改，而应该做组合成新类型。因为 vdom 是来自于 svg 的字面量，它的类型应该是非常详尽的 const 值类型，你也不好说是在 property 那一层设置类型为 property 应有类型，还是在 children 那一层设置类型。如果你设置了，那这里你就又得不到它的详尽的值类型了。 所以我们更想要详尽的值类型，但是这样就不存在修改一说了，所以应该是返回新值，新值有新类型(因为这里的新类型后续我们其实没有使用的需求，所以模糊点也无所谓，只要是个 VNode 就行了)。
即 vdom => ({...vdom, children: vdom.children.slice(0,1).concat({...vdom.children[1],fill:'yellow'}, vdom.children.slice(2))})
要求这么完善的类型，也的确很复杂。
其实就算这样，可能也不合适，例如 外部设置 children[1].fill = 'yellow' 原本是想设置那个 rect 的颜色的，但假如内部代码改了下 circle 和 rect 的顺序，那么从类型上来说，他们仍没有错，但从意义上来说，就完全错了的（当然，这个时候子组件目的完全改变，哪怕是 耦合性低 的那种方式也应该通知父组件看要不要做改动，这从依赖上来说一样是父依赖了子的具体内容）

可能还有人觉得 灵活程度低的方式 有别的优势 ---- 封装逻辑。例如只需要在 props 里传一个 color，则 svg 里好多个元素的 color 都发生变化。这个要用 方式二 来实现就要在方式二里写好些句代码。但其实这可以写成对这个 svg 做处理的工具函数，跟 svg 作为一个整体供使用者调用，因为 svg 和 工具函数是封装在一起的，所以代码可以少些。。。 不过不得不说，目前的编程语言的语法并不支持非常灵活的函数复用，所以工具函数本身可能也不会很小。 不能像方式一 一样 逻辑完全封装在一起那么小。

如果有天 编程语言 能灵活插入其他逻辑，形成新函数，例如：
```
function svg() {
  return <svg>
    <circle fill="A: red" />
    <rect fill="A: red" />
  </svg>
}
function svg_helper() {
  return svg.A("blue")();
}
```
好吧，好像这种工具函数 与 方式一 没有区别。

另外需要注意，方式一与方式二并非完全冲突（他们有一定冲突，例如方式二按理来说应该是要求原来的东西是常量），他们完全可以合并起来。提供个好用同时也足够灵活的 builder
