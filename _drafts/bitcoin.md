https://github.com/trustnote/document/blob/master/TrustNote-Whitepaper.md

对于劣币驱逐良币的问题，有两种方法：

1. 首先也是有一定数量的币（21,000,000），然后挖到最后之后，人们会继续挖矿，算力小于某个值 a 时，挖矿只能得到之前的交易的手续费。算力大于 a 时，就能够挖出新的币。。。而 这个 a 则需要设计者在开发之初就预估出 到 21000000 个币都挖完之后（即2140年，该币种的价格与算力的比值，这就是 a）。。。如果预估不出来，就只能一开始就是 0 个币了，直接定一个 a就是了。。。这种有缺点就是后续所有的 GDP 增长，会有一半被浪费在无意义的挖矿中；

2. 花该电子货币来投票，花的钱越多，决定权越大，决定今年新出现多少个币。。。如果新出货币少，自然没问题，只是经济增长慢而已。。。如果新出货币多，那就是通胀，货币变得不值钱，受损的还是富人，因为穷人也可以参与挖矿(从而逼着富人做出共赢的决定)

3. bitcoin 哪怕有投票定通胀，仍然需要挖矿，而挖矿就是浪费一半GDP。。。应该做出有意义的事情（例如博客点赞），让区块链承认，以此来代替挖矿。。。最有意义的事情，应该是“学习”，这样的话，一般的劳动力通过学习来生产币，另一半的人通过创新来生产价值，双方互换币和价值，就形成了社会的发展。。。当然，如果区块链能直接承认“创造价值”，那就更简单了。。。


基于媒体点赞形式的比特币
点赞需要消耗手续费，从而杜绝机器点赞
最终把点赞的手续费和普通手续费，还有投票定出的通胀的部分三者都合起来，按照点赞比例分给获得赞的账号。。。
还有挖矿的人负责存储数据，发布媒体文件时需要交纳占用硬盘的租金（按时间付费）


点赞手续费 + 交易手续费 + 投票定的通胀 === 接受赞的人获得的钱 + 挖矿的钱
挖矿的机器越多，则系统越稳定，当然，消耗的电也越多
所以人们可以投票决定分给挖矿的钱占总钱的占比。。。

点赞其实就相当于在线购买虚拟物品，因为卖家可以自己买自己的虚拟物品，这样就完全相当于给自己点赞了，消耗一个手续费。。。
于是为了实现更多样的流程：不免费的虚拟物品售卖（购买并点赞才能下载）、免费的虚拟物品售卖（点赞直接下载，否则无法下载）、免费的虚拟物品先体验后售卖（免费下载，后自己决定是否点赞）
所以才应该有单独点赞的概念。。。而前两者，完全可以做在系统之外


支付需要是匿名不可追踪的，而不是比特币的公开的（否则哪怕有不可被封锁的网络，也易被ZF抵制）
- 不不不，不需要是匿名的。。。因为在 ZF 不支持比特币的时候，人民用比特币的方式是有一个中间商，接受比特币即时兑换 ZF 现金的服务，然后人们用 比特币 作为自己的资产存储，用的时候就临时兑换一下。。所以只要那个中间商可以帮人保密就行了

比特币会被受到量子计算的威胁：会受到威胁，但不用担心，可以靠升级去解决社会问题。。。全球所有人都在使用比特币。。。量子计算机出现了，于是产生了受人信任的机构（即国家），这些机构开始印钱，人们各自向自己信任的机构用比特币兑换钱，（至于中间的空窗期有哪些账户的钱被量子计算盗去，那只能是倒霉），等到免疫量子破解的算法出现，那些机构合作开发新的币，按照机构拥有的比特币比例，决定新的币里各机构初始拥有的币的数量。。。然后机构再让自己下面的民众用现金兑换新币。。。如果机构根本不开发新币，或者之后不给民众兑换新币的机会，那也只是普通民众再受一次机构剥削，渐渐转向(开源的)新币。。。
其实中间那个换现金的环节，如果开源开发能免疫量子攻击的新币的速度足够快，那换现金的环节是可以省略的。。。开发出新币的团队提供一个旧币换新币的服务就行了

币的迁移（从 A 币迁移到 B 币，可能的原因包括 B 币的系统有很多其他优点）：上面说的经过一个中间机构是可行的，不过会有人受损。。。
开发团队提供的旧币换新币的服务，它应该有更具体的概念。它可以是：
方式一：开发团队公布一个旧币地址 a，然后全球所有的旧币矿机都升级成为仅认同该地址收钱，但不认同该地址付钱的交易，然后人们拿旧币买新币。新币由第一个新币持有人设置较大的通胀率来产生新币。(这里面的汇率由市场决定，最终成为大部分人都只持有新币，所有的旧币都在 a 地址上了，旧币矿机都不干了，旧币自然就全部失效)
方式二：新币协议本身自带一个旧币客户端，且定义了一个旧币地址 a，新币协议不认同从 a 地址发出的交易。人们向 a 地址支付旧币，


1. 投票决定通胀，钱越多，决定权越大；因为通胀的钱不一定会被钱多的人拿到，所以对钱多的人而言不一定有利，要看他们能不能做到双赢;
2. 投票决定挖矿收益占（通胀+手续费）的比例，钱越多，决定权越大；因为挖矿决定系统稳定性，钱多的人肯定更希望系统能稳定运行;
3. 自己给自己消耗手续费无法获利（没必要有点赞系统，点赞只相当于0元交易的手续费）

甚至根本不需要 2...挖矿的人只获得手续费，出手续费的人获得通胀

假设没有 2 。。。假如一富翁占全世界 80% 资产，其他人占 20%。。。然后下一个节点，决定通胀到 150%，富翁出了全世界资产的 9% 作为手续费，其他人出 1%。。。于是
(80 - 9) + (50 * 0.9) = 116
(20 - 1) + (50 * 0.1) =  24
                    剩下 10 被矿工作为手续费拿到。。。如果矿工是富人，那贫富差距加大；如果矿工是穷人，那贫富差距减小


不过单纯没有 2，也可能出现浪费太多电力在挖矿上。。。也许可以加上 2。。。另外，把点赞区别于普通交易，可能也有一定积极意义。

- 交易表示法-A:
交易：
  付款地址
  付款方加密信息
  收款地址
  付款数量
  手续费：手续费是付手续费的一方的加密信息与手续费数量。。。
        从而可以收款方付手续费，甚至第三方付手续费。。。
        手续费就是一个无收款地址的交易

上面这种交易表示法需要再每次交易时都对交易对象找到所有的交易，并group一下，得到有的货币数量。。。
比特币的交易表示法则无需这样，只要能找到 input 的来源即可

- 交易表示法-B
比特币的交易是由输入输出的概念来达成的：

|transaction_name |input               |output          |desc
|-----------------|--------------------|----------------|-----------------------------
|mine_block       | NONE               |alice: 2        |alice 挖矿得到两个比特币
|cafe             | mine_block:0       |bob: 0.1        |alice 花 0.1 向 bob 买咖啡
|                 |                    |alice: 1.89995  |
|                 |                    |mine: 0.00005   |
|book             | cafe:0             |foo: 0.01       |bob 花 0.01 向 foo 买书
|                 |                    |bob: 0.08995    |
|                 |                    |mine: 0.00005   |
|new_book         | book:1             |alice: 0.01     |bob 花 0.01 向 alice 买书
|                 |                    |bob: 0.0799     |
|                 |                    |mine: 0.00005   |
|gameboy          | cafe:1             |foo: 0.9        |alice 花 0.9 向 foo 买gameboy
|                 | new_book:0         |alice: 1.0099   |
|                 |                    |mine: 0.00005   |

上表其实不标准，bitcoin 里 mine_fee 是不会被记录进 output 里的，而是直接就 output - input = mine_fee

https://www.reddit.com/r/cryptodevs/comments/93nx7j/whats_the_benefit_of_the_way_bitcoin_representing/

比特币这种表示法
1. 需要每个 input 都有一个签名
2. 必须遵守前后顺序，即哪怕一个人余额足够，他的前一次交易也必须得在得到矿机确认后，才能得到找零，从而用找零做下一次交易
3. 同时用多个账户去支付一笔交易，顺带把账户间的资金也合并了
> 这种交易的代码本质就是：由一个人收集所有input的认证信息，并且任意编写 output，矿机检测所有 input 从未被用过，并且 output 比 input 小，即认为成功

希望有一种表示法能仅仅去查询所有交易中有限量的数据。。。可以简单的在付款方生成交易id，即 transaction_name 上 **加上日期**
交易表示法-A，如果维护一个所有非空账户余额表，可以给所有账户加一个信誉值，然后在账户发生低价交易时，可以快速交易，高价交易时，可以慢速交易，信誉值越高，交易速度越快，发生交易错误时，信誉值降低
交易表示法-B，会降低交易速度，前一次交易没确认，后一次交易根本无法进行（哪怕手机客户端知道应该进行后一次交易）。。。但是也有好处是原子交易有足够的灵活性（例如给全公司员工发工资可以在一笔交易中进行，是一个事务；三方合作交易也只在一笔交易中进行，是一个事务；发起交易后，output 中有一个是自己的新账户，从而达到匿名效果，外界不清楚到底是哪个是收款人，哪个是新账户）

。。。其实交易表示法-A 也可以有 B 的优点，形式是 B 的形式，只是把 mine 的费用主动标注出来，而不是 bitcoin 里 input - output = mine_fee 。。。这样，当出现 input - output > 0 的情况时，如果 input 只有一个地址，则剩下的钱返还给 input。。。如果 input 里有多个地址，则错误。。。
不对，应该是 input 里有地址和出钱数，始终保持 input >= output，仍然是 mine_fee = input - output。与 B 唯一不同的是，input 是地址与出钱数，而不是什么找零，根本不存在找零。
- 最终，新区块中有所有金额发生变化的地址的即刻金额数。如此，找一个账户的金额，只需要当前区块，和正在发生的交易temp，再加上如果前两者合起来找不到，就再结合再往上层区块找

~~对于隐私服务，可以成立一个隐私服务公司，有隐私需求的人 p1（例如想通过比特币向ZF支付钱），p1 知道要支付多少钱，先把钱支付给 隐私服务公司 p2 新生成的一个账户 p2x ，然后 p2 从自己的别的账户 p2y 中把钱签名了，给 p1...然后 p1 使用这个签名（这个签名里有一个交易 id，但没有收款人，后续别人可以修改收款人，交易id只可以用一次），生成一项支付，最终出来的是 p2y 支付了这份钱。。。p2x 里的钱会被隐私服务公司的别的客户用作 p2y~~ 。。。  *没有这个后续可以修改收款人的签名交易。。而是直接 p1 给 p2 付钱了，然后用 p2 的软件扫ZF支付码， p2 帮 p1 把钱付了。。。p1 无需向ZF证明 p2x 是属于自己的，而是 ZF 在收款时会新生成一个地址（这个地址只有 p1 知道），然后只要是付到这个地址上的钱，都算 p1 付的*...如果是有多付款方，那这个`没有后续可以修改收款人的签名交易`的方案就不行了，它只能用于单付款人方案....
> 其实，支持“有后续可以修改收款人的签名的交易”也可以，因为重点只是协议本身，是消息的格式，至于后面消息怎么存储，完全可以各自有不同的方案。。。不过支持这种多付款人交易，也让消息的格式本身变得复杂许多。
单付款人: `from_pubkey + [to_pubkey + amount]+ fee + content + pri_pri(remark) + pri_pub(hash(before))`
多付款人: `[from_pubkey + amount + random + pri_pub(hash(before))]+ + [to_pubkey + amount]`
付款有扫码支付和被扫码支付。。。被扫码支付就需要支持后续可修改收款人的交易。。。而且最好被扫码支付里，码里有限制最多付款数量的限制条件。。。另外，因为电子货币一个钱包里私钥太多，所以往往是多个私钥一块支付一个交易。。。。所以多付款人是必要的

<!-- 投票是表现在账户属性上的，然后这个属性应该加上当前区块号，并用私钥签名，从而无法作伪 -->
投票是发送一条消息，消息用私钥签名，然后等待矿工确认该消息，并把消息内容合并到账户属性中。。。
然后因为投票消息可能影响矿工收益，例如设置降低矿工获得的百分比，于是矿工故意不收录此消息，除非此消息的交易费抵消了百分比降低带来的损失。。。虽然有大额手续费的方法可以弥补，其实也可以让投票消息只在下一个区块中生效，当前区块不生效即可。。。

客户端可以设置自己的联系信息，然后旷工可以设置真实信息（普通人没必要设置），于是需要对协议做改进的时候，联系旷工就是
名字的版权属于开发组，从而协议改进时，只要有大矿工支持自己，改进就可以成功，至于小矿工不支持，也只能是分叉，但分叉后的名字就变了，开发组有名字所有权，分叉就会死
另外，不同的客户端开发组（安卓，电脑，ios）可以自己定自己的比特币地址，input 为这个地址的交易能够附带一些信息（交易上可以附带信息），客户端收到消息，就能得到提醒。。。（所以甚至客户端本身可以通过比特币网络得到更新）


Merkle 树的作用，目前看来仅仅是做交易验证用的，也稍微防止下全节点欺骗瘦节点。瘦节点知道一笔交易，知道它的所有信息，自然也知道它的 hash，要查看该交易的确认情况，知道该节点在哪个区块上，知道该节点是通过怎样的方式在那个区块上（就是要全节点构造出通过该交易构造出区块的路径，这种情况下，全节点很难轻易欺骗构造出完整路径，另外就是让完整路径尽量小，从而瘦节点校验一个交易的下载量变小）

比特币的区块有 1MB 的大小限制，是为了让挖矿节点能快速上传挖矿结果并被确认而设置的。。。但是完全可以不做限制，只要协议里有一个约定好的确认哪个区块的方案就好了：
- 例如可以节点先收到一个来自 a 的区块，区块传了一部分，还没传完，又收到了来自 b 的同一层的区块，可以以最先开始接收谁为准，如果最先开始接收 a，接收完 a 后还要校验 a，如果 a 非法，就校验 b（接收 a 的过程中也在接收 b）。。。另外，接收到 a 的头了就可以边接收 a，边广播 a
- 也可以最先接收完谁，就以谁为准（不过这样，大家可能就都倾向于制造小的区块了，也不一定，小区块的交易数少，手续费少，也不一定好，另外也鼓励用户不要创建大交易，避免被矿机延迟接收。。。另外，还有设置改变通胀的交易信息，设置让挖矿者拿百分比的交易信息，如果是降低百分比，那几乎就没有旷工会收录了，除非这条信息的交易费超过了减小的百分比的损失）。。。。 **从这里其实可以看出，区块链就是个聊天室，所有的人都可以说话，都为自己说的话签名**
- 还可以有一套判断区块价值的函数，例如：交易数越多，区块价值越高；涉及金额越多，区块价值越高；交易越老，区块价值越高；挖得该区块的矿工获利越少，区块价值越高。。。（不用担心有矿工会故意留下交易不放进区块里，从而让自己下次的区块价值变高，因为完全可能这交易被别的矿工在本次区块中就确认了）

> 区块链是一个全球聊天室，所有人都可以说话，都为自己说的话签名
于是，区块链可以做身份识别，一个地址付款买一款游戏，之后用户换电脑，要重新下载游戏激活游戏，可以用这个地址签名，说一句话，游戏运行商在区块链里检测到那句话，就可以激活游戏。。。
所以，一条消息应该包含：钱的部分（私钥加密，公钥解密），用户自己的 remark（私钥对称加密，公钥无法解密，只能用户自己看到），消息内容部分（私钥加密，公钥解密）。
私钥加密，公钥解密其实都是明文，加上签名（签名是对明文的 hash，在做私钥加密，让公钥解密，发现 hash 值与明文的 hash 值相同，即签名成功）

> 区块链是全球聊天室，一般发送公开消息，为自己说的话签名；有时也可以发送私密消息，用别人的公钥给自己的消息加密，得到最终的加密后的自己的消息，然后签名，别人用私钥解密消息。
> 发送加密消息可以有的场景是在线购物，系统生成订单号，生成支付二维码（里面有支付地址以及订单号，以及商户的加密公钥），用户扫描支付二维码，用加密公钥加密订单号，向这个地址发送钱。系统在区块链上监控到此消息，解密得到订单号，知道订单支付成功。订单号需要加密，从而保证用户隐私。
*然后签名和加密用的是两套算法，两套公私钥，虽然本质上可以是一套，但并不安全（https://security.stackexchange.com/a/1819）。。。所以，可以是地址由两个公钥组成，用户背后需要保管两个私钥；也可以是地址只有签名的公钥，用户背后也只有签名的私钥，一开始根本没有加密功能，如果用户希望别人能给自己发送加密消息，可以在自己的 account model 上加上加密公钥，而且之后还可以换*

人们可以在内容部分上操作，在内容上做之前的开发组消息推送，可以做到 p1 用 p1x 地址向 p2 的 p2x 地址发钱，p2 使用 p1x 的公钥加密一个激活码，发给 p1x，甚至能做到在内容部分上做论坛


比特币的 blockheader 中 nonce 占 4 字节，但是显然 10 分钟不可能只计算 hash 仅仅 2**(4*8)=40 亿次，而是每次有新消息新 transaction 进来时，都重新计算 merkle ，让 nonce 重新从 0 开始。。。如果 nonce 计算完，却还是没有新 transaction 进来，就自己主动修改下 coinbase 里的一个时间，从而修改 merkle，重新计算 nonce。。。这样可以的原因是因为计算得到的 hash 本身就被认为是随机的，所以是不是即时修改 merkle 都无所谓的。。。当然，似乎可以把计算`hash(current_blockheader_with_nonce) < current_blockheader_target`，变更为计算`hash(previous_blockheader_hash + nonce) < current_blockheader_target`。。。
> 不过考虑到如果能避免 51% 攻击，让普通电脑也参与挖矿，但无需完整节点，可以有完整节点接受查询请求以帮助瘦节点验证交易准确性，瘦节点只是挖矿和收集交易，并调用不同的完整节点来验证交易准确性。
而不能是矿池主机发下任务`get_nonce(previous_blockheader_hash, current_blockheader_target)`，瘦机器得到 nonce 后就直接发给矿池主机。。。因为这样无法控制主机修改 transaction。。。所以，放弃`hash(previous_blockheader_hash + nonce) < current_blockheader_target`的形式。。。。*这样无法控制主机修改 transaction 是指：挖矿本身是为了结算交易，分布式挖矿是为了让结算更去中心化，自己这台瘦节点凭运气得到的 nonce，让自己有结算交易的资格，让自己这个好人更多参与进来，而不是得到 nonce，把 nonce 给别人，放弃自己的结算资格*


新币名字叫 “东方币(THC TouHouCoin)” 东方project(TouHou Project)，象征开源、自由。。。相对 liberty-coin 含蓄一些。。创世区块叫 zun ，东方 project 的创造者，temp 区块叫 xia，东方币的创造者。

矿机创建区块后，可以在区块上加上自己的录入交易的标准，然后客户端在创建交易时，可以看最近一段时间内的标准，根据这个标准来决定手续费。。。
因为 THC 里使用 account model，所以很久以前的交易，矿工可以不存，只留下一个交易的 hash 就可以，之后别人问起这个交易的时候，可以从区块的 merkle 上找到这个 hash


SPEC: - 多付款人
6 字节表示时间，从 1970 到现在的 ms 数，时间既是时间，也充当 random，不需要 tx_id，签名就是 tx_id
钱币数量用: 第一个字节表示后面的数字占字节数，后面的是无符号整数
大小用约等于即可：1个字节即可表示，前两个bit 控制单位是 B KB MB GB，后六个bit是数量，最大64GB....算了，还是 f32 好了...也有 f16 叫做 half 的，但是这个标准最大表示的数字太小。。。其实是这个标准有问题，16个比特，能够表示的范围还是很大的，带符号的话，是 `-(2-2**(-10))*(10**15) to (2-2**(-10))*(10**15)` 如果不带符号，连指数也不带符号，1个字节也 ok... 4位指数，4位尾数的小数部分，则最大是 `(2-2**(-4))*(10**(2**4-1))`。。。。还是 f32 吧，标准

消息 = 版本 - 大小 - 手续费 - 交易
版本与钱币数量表示方式一样
交易 = [交易] | [input] - [output]
input = pub + time + amount + sig   106
output = pub + amount               36
交易中不一定有 input，也不一定有 output。。。最终交易通不通过看整个 message 是否通过...
> 错了，sig 不在 input 中，sig 是在交易中的。。。不然，别的人得到了交易，直接把 input 取出来，自己替换 output 就可以提交了。。。于是多 input 交易，每个 input 里面的签名就不会是只签名自己这部分交易（否则会让帮忙广播的人或者矿工把某个 input 提取出来，用于自己上），签名还不能是某个无意义的共用字段（因为别人也可以提取出 input 后，自己也加一个无用字段相同的 input），必须是整个交易，带上时间 all_sig = sign([from_pubkey - amount - time] - [to_pubkey - amount])...也就是合同一式多份，每份的内容都是相同的，合同涉及方都需要在相同的内容上签字
则：
type u_custom
> message = version(u_custom) - size(f32) - fee(u_custom) - from_pubkey - time(48bit) - [to_pubkey - amount(u_custom)]- sig
但是没有多 input 的话，不好做隐私保护：我有一个账户有 10000 元，买东西花 100，于是 output 1000 到两个地址，其中有个 900 是自己的。。依次，最后有 10 个 900 在不同的账户里，都是自己的。。。然后要花 3000 买一东西，于是只能变成 4 个 transaction。。。这是不可接受的。。。于是变成大家始终只用一个 address，根本不 output 到自己的新零碎账户，于是隐私轻松泄露
。。。多 input 的话，需要每个签名里有其他所有 input 的 pubkey。。。于是可以是 整个交易的所有 input 的 hash 数组，排序，合并，后的 hash。。。
- 自己的 input 中只有有别人的 input 的 pubkey，则是我把我的钱给你用，但不管你怎么用
- 自己的 input 中有别人的 input 的整个 hash，则是我的我的钱与你的钱一块使用，整体是一个事务，要不全 ok，要不全 不ok。。。**选这个**，也就是说，大家的签名都是对完整的消息内容的签名，而不是仅仅自己决定的部分的消息内容的签名。。。或者说根本没有自己决定的内容部分的概念
> tx = [from_pubkey - amount(u_custom) - time - all_sig] - [to_pubkey - amount(u_custom)]
> all_sig = sign([from_pubkey - amount - time] - [to_pubkey - amount])
> message = version(u_custom) - size(u_custom) - fee(u_custom) - tx // fee 有重复，可做校验

type u_custom 其实程序界有对应的概念，叫 varint ...甚至 var_unsigned_int 可以在一个字节中，用 1 bit 表示后面跟不跟数字，7 bit 表示数值 ... https://github.com/multiformats/unsigned-varint

一开始只 version size fee 是 uvar，其余都是 json ，用 js 的 ArrayBuffer 连起来


区块链的形式，以及 Proof of Work 的共识机制，决定了最终当全球所有人都使用 touhou_coin 的时候，本质上只有一台电脑在处理全球所有交易，于是很可能性能会出现问题，大家不得不把手续费给堆高起来，并且设置（手续费+通胀）中矿工获得的比例增加。。。但矿工得到更多的钱也只会促进别人普通的挖矿，去计算那个无用的数字。。。所以，之前说过的 **一套判断区块价值的函数** 是有必要的。必须得把挖矿跟交易结算给绑定起来，同时挖出的区块，结算的交易越多，该区块被承认的可能性越大，从而矿工为了提高挖矿成功率，就得想办法提高区块质量，而不仅仅只是计算那个无用数字，于是，哪怕只是一台电脑，矿工们也会用钱砸出技术出来，使之能够处理更多的交易。

> 分布式挖矿是：区块头里带的是自己这个区块，而不是上一个区块的 hash。。。然后有完整节点愿意提供付费服务，瘦节点接收到交易，会去查询完整节点该交易是否有效，有效就保留下来，继续算区块，查询一次需要付费一次，然后瘦节点还可以定时查询完整节点那里有多少交易，可以下载下来，从而提高自己这个区块的价值，提高其竞争性。



币里不存在小数，然后不同账户设置的通胀系数不同，按比例计算太过麻烦，而且可能出现小数舍弃太过奇怪的情况。。。所以就账户的钱乘以账户自己的通胀系数，然后舍弃小数部分，即 Math.floor(amount * tongzhang)。用 floor 不用 ceil 的原因是不要让零散账户对整个系统产生影响，鼓励不要出现零散账户，另外也避免穷人通过把自己的钱放到零散账户中来提高决定权，保障绝对公平。。。但其实也对穷人不利，因为单个的决定权损失没有区别，但总体的全世界所有的穷人损失的决定权要多一些。。。还是用 round 吧，平均更公平些


要考虑消息发送顺序和时效。。。例如自己有全世界 10% 的钱，用掉 9% 的钱，剩下 1%，然后设置自己的通胀系数为 100。。。但是，可能会有人用这个做文章，延迟确认花掉 9% 的钱，提前确认通胀 100。。。从而破坏系统。。。这里要思考：在假设大部分矿工是好矿工的时候，坏矿工做坏事情是否存在囚徒困境

------------

有了 touhou_coin 之后，初始给自己分配 1,000,000,000 个币，即十亿分，一千万元。
好好设计公式，计算自己的矿机占有的算力比例，决定自己要设置的通胀系数，最大限度提高自己作为创始人的收益。
可以设计个交易站，用户把 touhou_coin 存入交易站，转账时支付手续费，手续费的通胀归交易站；
可以利用自己的知名度设计个即时交易站，类似支付宝，大家把 touhou_coin 存入支付宝，用支付宝进行日常交易，保证交易速度。。。支付宝本身可以使用大家存进去的钱去投资。





-----------

p2p 文件系统，不知道 ipfs 怎么做的。。。自己只想做两个:
一个是固定的文件，就它的 hash 就是它的 id，用这个 id 可以广播下载此文件；
另一个是动态的文件（文件夹），主人对文件有修改权限，修改后会带时间戳（其实不是时间戳，而是修改层数）。。。当主人丢失权限秘钥后，其他人可以基于这个动态文件的 id 和 层数，补充新 id + 层数。。。于是普通用户查找旧 id 时，能发现那个文件以及其很久以前的更新，也能找到别人对那个文件的新的更新，自己选择选一个去 subscribe

然后对于这个客户端而言，存储到硬盘的文件都被零碎的缓存化，用户除了通过客户端进行访问外，不能单独访问。。。如果这些缓存被修改，被删除，会被修复。。。用户如果想要传统的文件，需要使用客户端从缓存中下载为传统文件。。。。
缓存分两种，用户可以选择一部分缓存，进行锁定（仍然是零碎的缓存），另一部分缓存是自动的客户端根据访问频率和硬盘空间限制，自动删除。。。
还有下载一个动态文件里的部分（下载一个文件夹里的单个文件），这时候把它当固定文件。。。然后客户端本身知道这个固定文件是在一个动态文件内的，就看看这个动态文件之前的版本对应的文件，做出 diff 包，增量下载

于是 zeronet，就是先有一个动态文件（id 为 qwrbhesfq ），并且把秘钥丢掉，然后其他人都在此文件上更新新的文件 (id 为 qwrbhesfq-xxxxxx)，则所有 id 以 qwrbhesfq 开头的文件都是网站，有软件基于这个文件系统客户端做 web 服务器

Peer {
  pub_key_id
  direct_peers [
    pub_key_id
    connection_stream_sink
    direct_peers [
      pub_key_id
      direct_peers [
        pub_key_id
        ....
      ]
    ]
  ]
  all_peers [
    pub_key_id
    path_speeds [
      path: pub_key_id__pub_key_id__pub_key_id  这里不能形成环，最好也有层数限制
      speed
      connection_stream_sink
    ]
  ]
}

ipns: DNS 系统。。。人们在区块链聊天室上发布消息说自己要哪个域名，并支付价格，支付的钱也算作手续费，由最终比例决定分配，因为此时起到 DNS 服务器作用的是矿工。。。至于域名定价策略，是每个区块周期都支付一次钱，还是可以一次性支付很多次钱，另外别人与域名之前的拥有者的竞争价格，这些都有待敲定


dns on blockchain: domain 的归属权: 我支付的钱 + 我之前占据 domain 内 其他人访问此 domain 支付的钱 > 别人押的钱 ... 这样就可以继续占有此域名...更准确地说应该是类似 https://www.reddit.com/r/rust/comments/9adfnq/a_method_to_deal_with_crate_name_reservation_spam/ 由使用 dns 的人自己决定名字的意义...例如 google 之所以是 google, 并不是因为 google 公司买了域名, 而是全球那么多用户都认为 google 这 6 个字母组成的单词应该指向 google 公司的网站, 所以有一开始是 google 公司付钱买域名, 后来是全球用户替它付钱来维持全球用户对 google 这个单词的概念...但 域名应该是一个公益的概念, 所以全球用户理应不需要付钱, 只需要访问... 具体的还没搞清楚...

dns 就跟汽油发动机一样。。。往一个域名里放钱，就能让这个域名指向自己希望指向的地方。。。然后用户访问这个域名，用户可以出钱访问这个域名，出的钱就进入油桶。。。用户也可以不出钱，则油桶里的钱被消耗。。。另外，随着时间的过去，油桶里的钱也会慢慢减少。。。然后如果有其他人想要得到这个域名，则需要把支付比油桶里的钱更多的钱。。。


**何鸿燊 被称为爱国企业家**
我感到了 世上没有正义.... 所以, 想做 绝对自由 的博客系统, 和电子货币系统(匿名)
