https://github.com/trustnote/document/blob/master/TrustNote-Whitepaper.md

对于劣币驱逐良币的问题，有两种方法：

1. 首先也是有一定数量的币（21,000,000），然后挖到最后之后，人们会继续挖矿，算力小于某个值 a 时，挖矿只能得到之前的交易的手续费。算力大于 a 时，就能够挖出新的币。。。而 这个 a 则需要设计者在开发之初就预估出 到 21000000 个币都挖完之后（即2140年，该币种的价格与算力的比值，这就是 a）。。。如果预估不出来，就只能一开始就是 0 个币了，直接定一个 a就是了。。。这种有缺点就是后续所有的 GDP 增长，会有一半被浪费在无意义的挖矿中；

2. 花该电子货币来投票，花的钱越多，决定权越大，决定今年新出现多少个币。。。如果新出货币少，自然没问题，只是经济增长慢而已。。。如果新出货币多，那就是通胀，货币变得不值钱，受损的还是富人，因为穷人也可以参与挖矿(从而逼着富人做出共赢的决定)

3. bitcoin 哪怕有投票定通胀，仍然需要挖矿，而挖矿就是浪费一半GDP。。。应该做出有意义的事情（例如博客点赞），让区块链承认，以此来代替挖矿。。。最有意义的事情，应该是“学习”，这样的话，一般的劳动力通过学习来生产币，另一半的人通过创新来生产价值，双方互换币和价值，就形成了社会的发展。。。当然，如果区块链能直接承认“创造价值”，那就更简单了。。。


基于媒体点赞形式的比特币
点赞需要消耗手续费，从而杜绝机器点赞
最终把点赞的手续费和普通手续费，还有投票定出的通胀的部分三者都合起来，按照点赞比例分给获得赞的账号。。。
还有挖矿的人负责存储数据，发布媒体文件时需要交纳占用硬盘的租金（按时间付费）


点赞手续费 + 交易手续费 + 投票定的通胀 === 接受赞的人获得的钱 + 挖矿的钱
挖矿的机器越多，则系统越稳定，当然，消耗的电也越多
所以人们可以投票决定分给挖矿的钱占总钱的占比。。。

点赞其实就相当于在线购买虚拟物品，因为卖家可以自己买自己的虚拟物品，这样就完全相当于给自己点赞了，消耗一个手续费。。。
于是为了实现更多样的流程：不免费的虚拟物品售卖（购买并点赞才能下载）、免费的虚拟物品售卖（点赞直接下载，否则无法下载）、免费的虚拟物品先体验后售卖（免费下载，后自己决定是否点赞）
所以才应该有单独点赞的概念。。。而前两者，完全可以做在系统之外


支付需要是匿名不可追踪的，而不是比特币的公开的（否则哪怕有不可被封锁的网络，也易被ZF抵制）
- 不不不，不需要是匿名的。。。因为在 ZF 不支持比特币的时候，人民用比特币的方式是有一个中间商，接受比特币即时兑换 ZF 现金的服务，然后人们用 比特币 作为自己的资产存储，用的时候就临时兑换一下。。所以只要那个中间商可以帮人保密就行了

比特币会被受到量子计算的威胁：会受到威胁，但不用担心，可以靠升级去解决社会问题。。。全球所有人都在使用比特币。。。量子计算机出现了，于是产生了受人信任的机构（即国家），这些机构开始印钱，人们各自向自己信任的机构用比特币兑换钱，（至于中间的空窗期有哪些账户的钱被量子计算盗去，那只能是倒霉），等到免疫量子破解的算法出现，那些机构合作开发新的币，按照机构拥有的比特币比例，决定新的币里各机构初始拥有的币的数量。。。然后机构再让自己下面的民众用现金兑换新币。。。如果机构根本不开发新币，或者之后不给民众兑换新币的机会，那也只是普通民众再受一次机构剥削，渐渐转向(开源的)新币。。。
其实中间那个换现金的环节，如果开源开发能免疫量子攻击的新币的速度足够快，那换现金的环节是可以省略的。。。开发出新币的团队提供一个旧币换新币的服务就行了

币的迁移（从 A 币迁移到 B 币，可能的原因包括 B 币的系统有很多其他优点）：上面说的经过一个中间机构是可行的，不过会有人受损。。。
开发团队提供的旧币换新币的服务，它应该有更具体的概念。它可以是：
方式一：开发团队公布一个旧币地址 a，然后全球所有的旧币矿机都升级成为仅认同该地址收钱，但不认同该地址付钱的交易，然后人们拿旧币买新币。新币由第一个新币持有人设置较大的通胀率来产生新币。(这里面的汇率由市场决定，最终成为大部分人都只持有新币，所有的旧币都在 a 地址上了，旧币矿机都不干了，旧币自然就全部失效)
方式二：新币协议本身自带一个旧币客户端，且定义了一个旧币地址 a，新币协议不认同从 a 地址发出的交易。人们向 a 地址支付旧币，


1. 投票决定通胀，钱越多，决定权越大；因为通胀的钱不一定会被钱多的人拿到，所以对钱多的人而言不一定有利，要看他们能不能做到双赢;
2. 投票决定挖矿收益占（通胀+手续费）的比例，钱越多，决定权越大；因为挖矿决定系统稳定性，钱多的人肯定更希望系统能稳定运行;
3. 自己给自己消耗手续费无法获利（没必要有点赞系统，点赞只相当于0元交易的手续费）

甚至根本不需要 2...挖矿的人只获得手续费，出手续费的人获得通胀

假设没有 2 。。。假如一富翁占全世界 80% 资产，其他人占 20%。。。然后下一个节点，决定通胀到 150%，富翁出了全世界资产的 9% 作为手续费，其他人出 1%。。。于是
(80 - 9) + (50 * 0.9) = 116
(20 - 1) + (50 * 0.1) =  24
                    剩下 10 被矿工作为手续费拿到。。。如果矿工是富人，那贫富差距加大；如果矿工是穷人，那贫富差距减小


不过单纯没有 2，也可能出现浪费太多电力在挖矿上。。。也许可以加上 2。。。另外，把点赞区别于普通交易，可能也有一定积极意义。

- 交易表示法-A:
交易：
  付款地址
  付款方加密信息
  收款地址
  付款数量
  手续费：手续费是付手续费的一方的加密信息与手续费数量。。。
        从而可以收款方付手续费，甚至第三方付手续费。。。
        手续费就是一个无收款地址的交易

上面这种交易表示法需要再每次交易时都对交易对象找到所有的交易，并group一下，得到有的货币数量。。。
比特币的交易表示法则无需这样，只要能找到 input 的来源即可

- 交易表示法-B
比特币的交易是由输入输出的概念来达成的：

|transaction_name |input               |output          |desc
|-----------------|--------------------|----------------|-----------------------------
|mine_block       | NONE               |alice: 2        |alice 挖矿得到两个比特币
|cafe             | mine_block:0       |bob: 0.1        |alice 花 0.1 向 bob 买咖啡
|                 |                    |alice: 1.89995  |
|                 |                    |mine: 0.00005   |
|book             | cafe:0             |foo: 0.01       |bob 花 0.01 向 foo 买书
|                 |                    |bob: 0.08995    |
|                 |                    |mine: 0.00005   |
|new_book         | book:1             |alice: 0.01     |bob 花 0.01 向 alice 买书
|                 |                    |bob: 0.0799     |
|                 |                    |mine: 0.00005   |
|gameboy          | cafe:1             |foo: 0.9        |alice 花 0.9 向 foo 买gameboy
|                 | new_book:0         |alice: 1.0099   |
|                 |                    |mine: 0.00005   |

上表其实不标准，bitcoin 里 mine_fee 是不会被记录进 output 里的，而是直接就 output - input = mine_fee

https://www.reddit.com/r/cryptodevs/comments/93nx7j/whats_the_benefit_of_the_way_bitcoin_representing/

比特币这种表示法
1. 需要每个 input 都有一个签名
2. 必须遵守前后顺序，即哪怕一个人余额足够，他的前一次交易也必须得在得到矿机确认后，才能得到找零，从而用找零做下一次交易
3. 同时用多个账户去支付一笔交易，顺带把账户间的资金也合并了
> 这种交易的代码本质就是：由一个人收集所有input的认证信息，并且任意编写 output，矿机检测所有 input 从未被用过，并且 output 比 input 小，即认为成功

希望有一种表示法能仅仅去查询所有交易中有限量的数据。。。可以简单的在付款方生成交易id，即 transaction_name 上 **加上日期**
交易表示法-A，如果维护一个所有非空账户余额表，可以给所有账户加一个信誉值，然后在账户发生低价交易时，可以快速交易，高价交易时，可以慢速交易，信誉值越高，交易速度越快，发生交易错误时，信誉值降低
交易表示法-B，会降低交易速度，前一次交易没确认，后一次交易根本无法进行（哪怕手机客户端知道应该进行后一次交易）。。。但是也有好处是原子交易有足够的灵活性（例如给全公司员工发工资可以在一笔交易中进行，是一个事务；三方合作交易也只在一笔交易中进行，是一个事务；发起交易后，output 中有一个是自己的新账户，从而达到匿名效果，外界不清楚到底是哪个是收款人，哪个是新账户）

。。。其实交易表示法-A 也可以有 B 的优点，形式是 B 的形式，只是把 mine 的费用主动标注出来，而不是 bitcoin 里 input - output = mine_fee 。。。这样，当出现 input - output > 0 的情况时，如果 input 只有一个地址，则剩下的钱返还给 input。。。如果 input 里有多个地址，则错误。。。
不对，应该是 input 里有地址和出钱数，始终保持 input >= output，仍然是 mine_fee = input - output。与 B 唯一不同的是，input 是地址与出钱数，而不是什么找零，根本不存在找零。
