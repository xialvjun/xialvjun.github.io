# BraveSpeaking 勇敢说
大家通常没有说英语的环境和需要, 这里就是制造一个说英语的环境. 后台创建大量的剧本(中文剧本), 剧本内有多角色. 用户进入 app, 创建房间, 选择剧本, 选择难度[^1], 选择是否公开[^2], 设置密码(可以无密码). 最终创建房间, 进入房间等待页面, 选择自己要的角色, 同时其他人也能在房间列表中找到此房间, 进入房间等待页面, 同样也选择自己要的角色, 可以请求交换角色, 等进入人数与剧本人数相同, 倒计时 5 秒, 开始演剧本... 其实这里跟王者荣耀, 或者 浩方对战平台的 dota1 类似. 在演剧本中, 根据房间难度, 与当前这句话的长度, 来决定系统等用户多长时间, 时间过去后, 自动轮到下一个人说话

todo: webrtc ?

> [^1] 难度决定轮到某个角色说话的时候的自动计时时长.
> [^2] 是否公开决定在房间列表中是否显示, 不公开则只有在房间列表中搜索房间, 输入房间号完全匹配时才会显示


# iqizou (一起走 / be_with_you) iqizou.site namecheap 2year 8.88$
产品介绍 和 产品宣言
这是一个能让人大胆表露自我的相亲平台.
你是处男, 想找处女当老婆?
你想找一个不在乎自己邋遢的老公?
你已经很累了, 想找一个不要求自己上进的人清贫地过一生?
在这里, 你可以匿名表达所有自己不敢表达的观点, 找到志同道合的另一半, 一起走.

产品流程
用户注册, 填写自己的基础信息(昵称, 性别, 要找的性别), 可选信息(身高, 工资, 房产), 问卷

流量
网站自带流量, 用户可以把自己的个人页传播出去(为了避免所有人都知道那是自己, 可以选多个人传播)

交友(这个是特殊交友, 但的确能有交友基础, 为了未来的发展, 所以账户系统需要做起来, 但因为是特殊交友, 所以小号要有-即账户合并)

通过
- 首页
  - 列表
  - 登录
  - 



# clubhouse 启发的
创建房间，房间内 9 个人有权限直播视频，20 个人有权限直播语音，50 个人有权限直播发送文字，无数个人可以进房间当吃过群众。。。上述数字可以更改。。。
它可以用作 吵架、争论，让大家评理
可以用作 观看学习某一个团队。。。
创建房间的人是房间主，可以分管理员。。。房间内是管理员先开启一次直播，之后才上述直播。。。管理员可以结束直播。。。一次直播结束后，整个直播的录像都被保留下来，形成房间的直播列表。。。普通用户可以对单个直播发表评论。




很抱歉长时间未回复. 

我的能力和主要经历: 
https://github.com/xialvjun/xialvjun.github.io (里面的 _posts 目录里也是我的博客, 进嘀嘀之后倒是没怎么写了, 感觉大脑都被工作填满, 没有太多的积累.)

我目前的工作、状态: 
目前仍在嘀嘀工作, 基本都是做前端, vue,react 再加一些库画些图表地图之类的, 本身难度倒没啥, 上面说的大脑被工作填满主要是指量大, 以及历史项目和工作流混乱.

我对这个计划的想法，想了解或者参与的部分:
目前我对你的想法的理解是: 你想做一个通用的 “单数据中心，多用户，以数据操作为主” 应用的生成系统(其实我上面说的 web 应用, 个人感觉基本 99% 的 web 应用都能归于此类).
生成形式我不能说死, 但举个例子倒是可以:
让用户提供一个 BPMN 图, 分析此图, 找出所有的操作与状态, 对其进行分类, 什么是需要持久化的, 放在数据库里, 以及生成接口作为后端, 什么是短时间的, 放在前端界面里, 并用几个通用的组件(格子-列表, 浮层-详情, tab-树形)形成前端(这样形成的前端界面显然不能接受, 可以在 BPMN 图上加一些元信息并提供大量通用组件的子类组件).
这样前后端都有了, 后端也可以用提供的元信息来做优化操作(分库分表等).
当然, 也不只是 BPMN 图, 可能也有你说的 需求描述语言.
这里我想参与的是用分析出来的数据生成前端(大概算是 进度里的 三-前端框架-组件库 那一块儿?), 其实对分析得到数据 也感兴趣, 但没有此类技术.

问你的问题:
这个项目是一个极其依赖基础设计的项目, 当项目



# 根据技术栈找同志
找公司
找员工
员工填写自己偏好的技术栈，以及技术见解
公司填写自己在用的技术栈，以及技术观点 。。。 公司能看到员工的，决定跟员工交流后，员工能看到公司的，双方决定交流后，进入面试


# 舌战 （shezhan.com）
就是大家有话题，根据话题形成不同的流派，分别支持不同的流派，并且把支持的文章贴出来，让精品文章置顶，不要让知识被争吵淹没，也让后续的人能更清楚的看清各个流派的观点，选择自己支持的流派
-- 所有的系统都是天生支持小号（因为虚拟与现实连接产生的必然的问题）
-- 流派间地位应是相同的，他们的文章列表不能混到一起去，不然可能让谎言充斥系统
什么是话题？话题与话题之间是互相关联的，比如男女话题，可能在共产主义流派里，它就会被视为资本主义的一个衍生矛盾。谁创建话题？

知乎/普通网友 基于社会现象提出一个问题，然后网友给出很多答案，有许多观点，形成流派。。。
但是到底是怎么在互联网民主的过程中产生的呢？如果这个过程中有小编的存在，则运营成本和责任会变得非常大，而且不客观。。。
所以应该是，用户自己创建流派，说清楚自己流派的观点，与其他流派的区别，然后其他用户选择加入流派，并在内部对流派说明做修正。。。
因为流派是用户创建的，所以需要有认真程度的排序，越认真的流派越排前

问下，谁知道 贴吧的运营机制是怎样的啊，贴吧的某个具体的吧 是由某个用户创建出来的吧，然后这个用户就是那个吧的吧主，然后吧主有绝对的权限，吧主可以给别人管理的权限，可以把自己的吧主给别人，整个的机制就这么多是吧
普通吧员 可以发文章，发评论，管理和吧主可以对文章加精，置顶。。。整个其实并没有一个民主的过程是吧

吧主的票选机制是：
不存在选不选的问题。
首先，你本人得申请吧主。具体条件你可以在申请的时候仔细看。
然后，你得得到现任所有吧主的同意。
再次，百度管理员确认，如果符合以上两个条件，你差不多能当吧主了

看来吧主不适合流派。其实流派并不需要流派主，流派只有流派名字，流派介绍，和流派文章列表。流派文章列表自己内部人点赞排序。一个流派对于一个问题只能发一篇文章（文章内部可以引用其他文章（前端阅读器内部展开），可以链接其他问题（这里对于那个问题不算回答数））。一个普通人对于一个问题，只能选择支持一个流派的文章。

所以整体流程是：
什么都没有
A 创建一个流派 X，写上流派名字和介绍（并非说这个流派就是 A 的，仅仅是 A 在 X 上有了一点活跃度）
有人问了一个问题
B 用流派 X 的名义发表回答 M
A 也用流派 X 的名字发表回答 N
M 与 N 在问题的回答列表里被合并折叠
普通人在问题的回答里的众多流派中选一个，在流派的关于此问题的众多回答中爱点赞谁就点赞谁（可以多赞，因为一个回答可能是解决多个问题）。。。这里就是普通人在此问题中认同流派 X，与流派 X 有了一点活跃度

人为什么要选一个流派来回答，而不是自己创建流派，因为这可以让自己的文章复用流派在此问题下的支持人数
用户在问题下支持单个流派，用户在流派下支持多个文章（看文章的时候，与问题无关），文章在流派下回答多个问题，用户在多个流派下写多个文章。
上面的逻辑会造成 用户在单个问题下支持了多个流派的文章（例如文章作者在用户支持了自己后，又声明此文章可以回答另一个用户已经支持了其他流派的问题），这算他支持哪个流派呢？。。。出现冲突的情况则算用户没有支持任何流派，（虽然支持了多个文章，此时是一个脏数据状态，文章的支持数仍被保留，因为流派内部有排名，但两个流派的支持数都减一，因为这是流派与流派的竞争），等到用户上线后收到提醒，再选择一个流派去支持，就会把对其他冲突的流派的文章的支持都减掉（用户可以转为收藏）。用户在一个流派内是支持多个文章的，所以这是一个批量操作
用户为什么非要选一个去支持，而不是忽视提醒呢？是因为用户要针对问题表达自己的态度。原本的情况是 用户在a问题下支持文章A，在b问题下支持文章B，A与B是两个不同的流派的文章。然后 A 的作者选择声明自己的文章 A 能够回答问题 b，也就是A的作者不认同文章B的观点，他做出了自己的选择。而用户则必须迁就作者的选择，否则可以认为用户没有理解作者的观点。
作者只能支持文章所属的流派

user
group
answer
problem

流派内受支持的前 20 作者投票决定 流派名 和 流派简介。加入未来有更多的自定义项，例如 reddit，也可以由他们决定代理人。

```sql
-- 统一的用户表，可以所有系统合并成单点登录
CREATE TABLE users (
	id TEXT(36) PRIMARY KEY,
	human_id TEXT(36) NOT NULL UNIQUE,
	username TEXT NOT NULL UNIQUE,
	nickname TEXT UNIQUE,
	email TEXT UNIQUE,
	mobile TEXT UNIQUE,
	passsalt TEXT,
	passhash TEXT
);

CREATE TABLE groups (
	id TEXT(36) PRIMARY KEY,
	name TEXT NOT NULL UNIQUE,
	"desc" TEXT
);
CREATE TABLE problems (
	id TEXT(36) PRIMARY KEY,
  -- author_id 就不弄 REFERENCES users(id) 了，因为 users 表可能是外部系统的，也不想弄成复杂的 OAuth
	author_id TEXT(36) NOT NULL,
	title TEXT NOT NULL,
	detail TEXT,
	created_at INTEGER NOT NULL,
	updated_at INTEGER NOT NULL,
  rank_z INTEGER -- 浏览 1，like_problem 10，like_answer 3，group_answer_problem 5，首次 group_answer_problem 20
  -- 上一句里的每一个操作增加多少的 z，从配置里读吧
  -- 则总的 heat = log10(rank_z) + seconds_of(now - '2008-12-01 00:00:00') / 45000 , 这个 heat 专业术语叫 SRRank
);
CREATE TABLE answers (
	id TEXT(36) PRIMARY KEY,
	author_id TEXT(36) NOT NULL,
	title TEXT,
	detail TEXT NOT NULL, -- answer 的 title 可空
	created_at INTEGER NOT NULL,
	updated_at INTEGER NOT NULL
);
-- 日志有三种，1 数据库日志，2 请求日志（但请求日志其实还跟后端代码的版本有关），3 业务日志。例如这里的对文本的修改记录，就是一种业务日志。虽然也可以用请求日志或者数据库日志去做，但会比较不直接。也许请求日志差不多可以
-- 在数据刚创建时 data_logs 就有记录了，而不是说非要等数据修改后才在这里增加一条记录，这样方便版本引用
CREATE TABLE data_logs (
	id TEXT(36) PRIMARY KEY,
	"_typ" TEXT DEFAULT ANSWER NOT NULL,
  item_id TEXT(36) NOT NULL,
	"data" TEXT NOT NULL,
	created_at INTEGER NOT NULL
);

CREATE TABLE problem_group_answer (
  problem_id TEXT(36) NOT NULL REFERENCES problems(id),
  group_id TEXT(36) NOT NULL REFERENCES groups(id),
  answer_id TEXT(36) NOT NULL REFERENCES answers(id),
	created_at INTEGER NOT NULL,
  PRIMARY KEY(problem_id, group_id, answer_id)
);
-- 不存储 group_answer_problem 的记录，需求似乎也不大，真需要时从 请求日志 中拿
-- CREATE TABLE group_answer_problem_canceled (
--   group_id TEXT(36) NOT NULL REFERENCES groups(id),
--   answer_id TEXT(36) NOT NULL REFERENCES answers(id),
--   problem_id TEXT(36) NOT NULL REFERENCES problems(id),
-- 	created_at INTEGER NOT NULL
-- );
CREATE TABLE user_like_answer (
  user_id TEXT(36) NOT NULL,
  answer_id TEXT(36) NOT NULL REFERENCES answers(id),
	created_at INTEGER NOT NULL,
  PRIMARY KEY(user_id, answer_id)
);
-- 似乎不应该有 user_like_problem_group 这张表，因为这张表的其实只是 user_like_answer 和 group_answer_problem 的合并视图，而且此合并试图逻辑较复杂，会有冲突剔除的情况，所以加个临时表，每次在 like_answer 和 group_answer_problem 时都检验下
-- CREATE VIEW user_like_problem_group AS SELECT * from group_answer_problem gap join user_like_answer group by problem_id, group_id;
CREATE TABLE user_like_problem_group (
  user_id TEXT(36) NOT NULL,
  problem_id TEXT(36) NOT NULL REFERENCES problems(id),
  group_id TEXT(36) NOT NULL REFERENCES groups(id),
  in_collision INTEGER,
  PRIMARY KEY(user_id, problem_id)
);
CREATE INDEX index_by_problem_id ON user_like_problem_group(problem_id);

-- user_favorite_xxxx 是用户的私人信息，纯粹的收藏。另外，user_like, user_favorite 以及 group_answer_problem 都因为请求很简单，所以不存储历史记录，真要记录时从 请求日志 中拿
CREATE TABLE user_favorite_answers (
  user_id TEXT(36) NOT NULL,
  answer_id TEXT(36) NOT NULL REFERENCES answers(id),
	created_at INTEGER NOT NULL,
  PRIMARY KEY(user_id, answer_id)
);
CREATE TABLE user_favorite_problems (
  user_id TEXT(36) NOT NULL,
  problem_id TEXT(36) NOT NULL REFERENCES problems(id),
	created_at INTEGER NOT NULL,
  PRIMARY KEY(user_id, problem_id)
);
CREATE TABLE user_like_problems (
  user_id TEXT(36) NOT NULL,
  problem_id TEXT(36) NOT NULL REFERENCES problems(id),
	created_at INTEGER NOT NULL,
  PRIMARY KEY(user_id, problem_id)
);
```
